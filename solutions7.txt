def fib(N) :
    '''
    return the N'th fibonacci number
    recall 1 1 2 3 5 8 13 ...
    '''
    a, b = 1, 1
    i = 2
    while i < N :
        i = i + 1
        a, b = b, a + b
    return b
#!/usr/bin/python3
from math import sqrt
# ----------------------------------------------------------e79.py
# Chapter 4.5: Modules: from module import something
#     show the two forms of import
# ------------------------------------------------------------

# use math.sqrt:  add all the squareroots of numbers from 1 to 100
# and print the answer with 2 decimal places of accuracy.


# ----------------------------------------------------

print('-------------------')
#!/usr/bin/python3
from e77_fib import fib
# ----------------------------------------------------------e80.py
# Chapter 4.6: Files: reading and writing
# ------------------------------------------------------------
# Explain file handle
# Write the fibonacci numbers from 1 to 20 into a file called fib.txt
# don't forget to close the file
# import the fib(() from e77_fib.py
# ----------------------------------------------------
f = open('fib.txt', 'w')
for i in range(1, 21) :
    f.write(str(i) + ' ' + str(fib(i)) + '\n')
f.close()

# ----------------------------------------------------
# open the file fib.txt for reading
# read the file fib.txt using:
# for line in filehandle
# ----------------------------------------------------
f = open('fib.txt')
for line in f :
    #line = line.replace('\n', '')
    #line = line.strip()
    #print(line[0:len(line) -1])
    #print(line[0:-1])
    print(line[:-1])
print('-------------------')

f.close()
f = open('fib.txt')
lines = f.read()
print('lines =', lines)
# ----------------------------------------------------

#!/usr/bin/python3
# ----------------------------------------------------------e81.py
# Chapter 5: Structured Types, mutability, higer-order functions
# So far we have the following object types:
# int     scalar
# float   scalar
# str     structured
# --------------------------------
# scalar type means no accessible internal structure
# structured type allows accessing length, index, slice
# tuple -- is simple generalization of string
# list
# range -- not a type in python2
# dict  -- dictionary
# ------------------------------------------------------------
# Chapter 5.1: Tuples
# ------------------------------------------------------------
# tuple -- immutable, ordered sequence of elements
# elements are any type
# elements not necessarily all the same type
# What does immutable mean?
# What is an advantage of immutability?
# ----------------------------------------------------
# Make examples of tuples and print them.
# ----------------------------------------------------
# t1 empty tuple
t1 = ()
# t2 tuple with several elements of different type
t2 = (1, 2, 3, 'blue', 'red')
# t3 tuple with one element ... note, this one is special
t3 = (3,)

# ----------------------------------------------------

print('-------------------')
#!/usr/bin/python3
# ----------------------------------------------------------e82.py
# Chapter 5.1: Tuples and their operations
# ------------------------------------------------------------
# concatenation example
# ----------------------------------------------------
# repetition example
# ----------------------------------------------------
# indexing example
# ----------------------------------------------------
# slicing example
# ----------------------------------------------------
# tuple containing a tuple example
# tuple is an object and elements of tuples are objects
# everything in python is an object
# ----------------------------------------------------







# ----------------------------------------------------

print('-------------------')
#!/usr/bin/python3
# ----------------------------------------------------------e83.py
# Chapter 5.1: Tuples and their operations
# ------------------------------------------------------------
# Write a function that uses tuples and returns a tuple
# (this is useful, since sometimes you want to return several things)
# --------
# Note that a for loop can iterate over elements of a tuple
# --------
# Note that the in operator works for membership in a tuple
# ----------------------------------------------------
def intersect(t1, t2) :
    '''Assume t1, t2 are tuples.
    Return the common elements'''
    result = ()
    for e in t1 :
        if e in t2 and e not in result :
            result = result + (e,)
    result = list(result)
    result.sort()
    result = tuple(result)
    return result
# ----------------------------------------------------
# Would intersect(t1, t2) be the same as intersect(t2, t1)?
# ----------------------------------------------------
t1 = (9, 1, 2, 3, 3)
t2 = (2, 4, 4, 9, 2)
print(intersect(t1, t2))
print(intersect(t2, t1))
print('-------------------')
# -----------------------------------------------------
# modify so that the two results would have the same elements, same length
# ------------------------------------------------------
# modify your solution so that the two results produce the same tuple
# ------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e84.py
# Chapter 5.1: Tuples and their operations
# ------------------------------------------------------------
# Sequences in Python allow multiple assignment
# The LHS length must equal the RHS length
# ------------------------------------------------
# Try it with a tuple and with a string
# ------------------------------------------------

#!/usr/bin/python3
# ----------------------------------------------------------e85.py
# Chapter 5.1: Tuples and their operations
# ------------------------------------------------------------
# Sequences in Python allow functions to return a fixed length sequence
# ------------------------------------------------
# Example of returning two things by a tuple
# ------------------------------------------------
def findextremedivisors(n1, n2) :
    '''
    Assumes n1, n2 are positive integers.
    Returns tuple of smallest common divisor > 1 and 
    largest common divisor >1.
    If no common divisor > 1 then return (None, None)
    '''
    minval, maxval = None, None
    for i in range(2, min(n1, n2) + 1) :
        if n1 % i == 0 and n2 % i == 0 :
            maxval = i
            if minval == None :
                minval = i
    return (minval, maxval)
# -------------------------------------------------------
# Try it out
# -------------------------------------------------------
print(5, 20, 'have extreme divisors', findextremedivisors(5, 20), 'expect 5, 5')
print(1, 20, 'have extreme divisors', findextremedivisors(1, 20), 'expect None None')
print(10, 15, 'have extreme divisors', findextremedivisors(10, 15), 'expect 5, 5')
print(10, 20, 'have extreme divisors', findextremedivisors(10, 20), 'expect 2 10')
print(20, 10, 'have extreme divisors', findextremedivisors(20, 10), 'expect 2, 10')
print(30, 105, 'have extreme divisors', findextremedivisors(30, 105), 'expect 3 15')
#!/usr/bin/python3
# ----------------------------------------------------------e86.py
# Chapter 5.2: range(start, stop, increment) is immutable
# ------------------------------------------------------------
# range can be indexed, sliced, length
a = range(5, 10)
print(a, 'expect range(5, 10)')
print(a[1], 'expect 6')
print(a[1: 3], 'expect range(6, 8)')
print(a[1: 100], 'expect range(6, 10)')
# ------------------------------------------------
# Example: index
# ------------------------------------------------
# Example: slice
# ------------------------------------------------
# Example: length
print(len(a), 'expect 5')
# ------------------------------------------------
# Example: try to mutate
# dir(a) and see no functions that mutate it
# ------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e87.py
# Chapter 5.3: lists and mutability
# ------------------------------------------------------------
# Example regarding id and equality
a = [1, 2, 3]
b = [1, 2, 3]
print(a == b, 'expect True')
print('id(a) = ', id(a))  # 139807222559432
print('id(b) = ', id(b))  # 140537758270280
c = 3
d = 3
print('id(c) = ', id(c)) # 10914560
print('id(d) = ', id(d)) # 10914560
# ------------------------------------------------
# Create lists A of evens, B of odds, C = [A, B], and D same directly
A = [ 2, 4, 6]
B = [1, 3, 5]
C = [A, B]
print('C = ', C) #  [[2, 4, 6], [1, 3, 5]]
D = [[2, 4, 6], [1, 3, 5]]
# ------------------------------------------------
# Check are C and D equal by ==, since they look the same
print('C == D', C == D) # True
print('id(C) == id(D)', id(C) == id(D)) # True
# ------------------------------------------------
# Check if they have the same id()
# ------------------------------------------------
# Show how C changes when A changes
A.append(100)
print('A = ', A) # [2, 4, 6, 100]
print('C = ', C) #  [[2, 4, 6, 100], [1, 3, 5]]
# ------------------------------------------------
# Note that C[0] and A are 'aliases' bound to the same object
print('id(C[0]) == id(A)', id(C[0]) == id(A)) # expect True
# ------------------------------------------------
# Exercise: Make three aliases to the literal list [1, 3, 2]
a = [1, 3, 2]
b = a
c = a
print(id(a), id(b), id(c))
# ------------------------------------------------
# Exercise: Make a thousand more aliases to that list
L = []
for i in range(1000) :
    L.append(a)
# ------------------------------------------------
# Show that the 1 in that list has the same id as 1
# obtained in different ways
print(id(L[0][0]), id(1))
# ------------------------------------------------
# Note: mutability of is convenient but 'treacherous'
# ------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e89.py
# Chapter 5.3: lists and mutability
# ------------------------------------------------------------
# Show that concatenation has no side effect.
# ------------------------------------------------
# Show that extend() has a side effect .. it mutates the list
# although it is like concatenation in one way
# ------------------------------------------------
# Show that append() has a side effect .. it mutates the list
# ------------------------------------------------
a = [1, 2, 3]
b = [4, 5, 6]
def p(x, m = 'junk') :
    print(m + ': ', x, id(x) % 1000)
# ------------------------------------------------
p(a, 'a original')
p(b, 'b original')
c = a + b
p(a, 'a after concat')
p(b, 'b after concat')
p(c, 'c after concat')
a.extend(b)
p(a, 'a after extend')
p(b, 'b after extend')
a.append('horse')
p(a, 'a after append')
d = 'cat'
p(d, 'd original')
e = d.replace('a', 'o')
p(d, 'd after replace')
p(e, 'e returned from d.replace()')
# ------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e90.py
# Chapter 5.3: lists and mutability
# ------------------------------------------------------------
# Showing some list operations
# ------------------------------------------------
L = [1, 2, 3, 0, 9, 4]
e = 9
i = 2
L.extend([4, 5, 6])
L.append(e)
L.count(e)
L.insert(i, e)
# index gives the index of first occurrence, exception if none
L.index(e)
# remove removes the first occurrence, exception if none
L.remove(e)
L.pop(i)
# defaults ot -1
L.pop()
L.sort()  # ascending
L.reverse()
# ------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e91.py
# Chapter 5.3.1: lists and cloning
# ------------------------------------------------------------
# Exercise: write in a naive way the following function
# i.e., looping through L1 while changing L1 (not a good idea)
# because of a hidden counter used by the interpreter
# ------------------------------------------------
def removeDuplicates(L1, L2) :
    '''
    Assumes L1, L2 are lists.
    Removes from L1 things that are in L2.
    '''
    for element in L1 :
        if element in L2 :
            L1.remove(element)
A = [1, 1, 2, 3, 4, 1]
B = [1, 2, 5, 6, 4]
print('A begins as', A)
print('now removing', B)
removeDuplicates(A, B)
print('A ends up as', A)
print('-----------------------------')
# ------------------------------------------------
# Exercise: write in a better way the above function
# i.e., looping through a clone of L1 while changing L1 
# ------------------------------------------------
def removeDups(L1, L2) :
    '''
    Assumes L1, L2 are lists.
    Removes from L1 things that are in L2.
    '''
    # this slice is a new copy of L1
    for element in L1[:] :
        if element in L2 :
            L1.remove(element)
A = [1, 1, 2, 3, 4, 1]
B = [1, 2, 5, 6, 4]
removeDups(A, B)
print('A after :', A)
# ------------------------------------------------
# Exercise: regarding the same function, 
# would the problem have been solved by looping through L2 while changing L1
# ------------------------------------------------
