# Programs developed in class for Lecture 11, Oct 20, 2020
# ----------------------------------------------------------e71.py
# Chapter 4.2: Functions: recursion   factorial and iteration
# ------------------------------------------------------------
# Write a function facR(n) that computes n! = n(n-1)!
# compare with facI(n), the iterative approach
# ----------------------------------------------------
# Write a program to try it out.
# -------------------------------------------------------------
def facR(n) :
    # base case
    if n <= 1 :
        return 1
    # general recursive case
    return n * facR(n - 1)

# -----------------------------------------------------------------
# Try the function on the following numbers
numbers = [0, 1, 2, 5, 10]
for number in numbers :
    print(number, facR(number))
print('-------------------')
#!/usr/bin/python3
# ----------------------------------------------------------e72.py
# Chapter 4.6: Files: opening and reading
# read a DNA file and calculate the percent of A and T
# ------------------------------------------------------------
f = open('sars-cov2.txt', 'r')
comment = f.readline()
print(comment, end= '')
print('---------------')
sequence = f.read()
seq = sequence.replace('\n', '')
length = len(seq)
countA = seq.count('A')
countT = seq.count('T')
percentAT = 100 * (countA + countT) / length
print("percent of AT is %.1f" % percentAT)
# ----------------------------------------------------
# Common operations on files summarized, from p. 63 in text
# ----------------------------------------------------
'''
open(filename, 'w')  open the file for writing, erasing what was there
open(filename, 'r')  open the file for reading
open(filename, 'a')  open the file for appending
filehandle.read() returns the whole file as a string
filehandle.readline() returns the next line from the file
filehandle.readlines() returns a list of lines from the file
filehandle.write(s) writes string s to the end of the file
filehandle.writelines(S) writes list S of strings line by line to the file
filehandle.close() closes the file
for line in filehandle :  fetches each line from the file, including newline
'''
#!/usr/bin/python3
# ------------------------------------------------------
# Circle module -- a separate file with circle information
# ------------------------------------------------------
pi = 3.14159

def area(radius) :
    return pi * radius ** 2

def circumference(radius) :
    return 2 * pi * radius

def spherearea(radius) :
    return 4.0 * area(radius)

def spherevolume(radius) :
    return (4 / 3) * pi * radius ** 3
#!/usr/bin/python3
# ----------------------------------------------------------e74.py
# Chapter 4.2: Functions: recursion   palindrome
# ------------------------------------------------------------
# Write a function isPalindrome(s)
#   with two helper functions
#   toChars(s) to make the lowercase version and remove non a-z characters
#   mention the ord(letter) function
#   isPal(s) to recursively check the resulting string after toChars()

# ----------------------------------------------------

def toChars(s) :
    result = ''
    s = s.lower()
    for letter in s :
        if letter.isalpha() :    #  'a' <= letter <= 'z'
            result = result + letter
    return result 

def isPal(s) :
    #base case
    if len(s) <= 1 :
        return True
    if s[0] != s[-1] :
        return False
    # general case
    return isPal(s[1 : -1])

def isPalindrome(s) :
    s = toChars(s)
    return isPal(s)

# ----------------------------------------------------
# Write a program to try it out.
# Try the function on the following strings (thanks to Wikipedia)
# ----------------------------------------------------
strings = ['racecar', 'storybook', 'mama', 'madam', 'A man, a plan, a canal, Panama!', "Was it a car or a cat I saw?"]

for s in strings :
    print(s, isPalindrome(s))

print('-------------------')

#!/usr/bin/python3
# ----------------------------------------------------------e75.py
# Chapter 4.2: Functions: recursion   multiply
# ------------------------------------------------------------
# Write a function multiplyR(a, b)
#   to multiply positive integers a and b using recursion
#   Write the recursive formula
# ----------------------------------------------------
# ----------------------------------------------------



# ----------------------------------------------------
# Write a program to try it out.
# Try the function on the following strings (thanks to Wikipedia)
# ----------------------------------------------------


print('-------------------')
#!/usr/bin/python3
# ----------------------------------------------------------e76.py
# Chapter 4.2: Functions: recursion   permutations
# ------------------------------------------------------------
# Write a function permutations(string)
#   that returns a list of all the permutations of the given string
# ----------------------------------------------------
def permutations(string) :
    #base case
    if len(string) <= 1 :
        return [string]
    #general case
    #cat cta act atc tac tca
    result = []
    for i in range(len(string)) :
        letter = string[i]
        rest = string[:i] + string[i+1:]
        for word in permutations(rest) :
            result.append(letter + word)
    return result
# ----------------------------------------------------
# Write a program to try it out.
# ----------------------------------------------------
print(permutations('a'))
print(permutations('at'))
print(permutations('cat'))
print(permutations('henry'))
print('-------------------')
#!/usr/bin/python3
# ----------------------------------------------------------e77.py
# Chapter 4.2: Functions: recursion   fibonacci, global variables
# ------------------------------------------------------------
# Write a function fib(n) that computes the sequence 1 1 2 3 5 8 13 ...
#   where fib(0) = fib(1) = 1, and fib(n) = fib(n-1) + fib(n-2) for n > 1
# Finger exercise, p. 54: how many calls to fib(2) when doing fib(5)
# ----------------------------------------------------
# Show how to count the number of calls to fib() by using a global variable
# Explain the dangers of global variables
# ----------------------------------------------------
def fib(n) :
    global numcalls
    numcalls += 1
    if n == 0 or n == 1 :
        return 1
    return fib(n - 1) + fib(n - 2)
# ----------------------------------------------------
# Write a function that tests fib() and counts the number of calls
# ----------------------------------------------------
def testfib() :
    global numcalls
    numbers = [0, 1, 2, 5, 10, 20, 1]
    #print('numcalls:', numcalls)
    for n in numbers :
        numcalls = 0
        print(n, fib(n), numcalls)
    print('-------------------')
    
numcalls = 0
testfib()

#!/usr/bin/python3
#import e73_circle
from e73_circle import *
# ----------------------------------------------------------e78.py
# Chapter 4.5: Modules: import statement
# ------------------------------------------------------------
# Add all areas of circles for radii from 1 to 50
# and report the total area to the nearest whole number
# ----------------------------------------------------
sum = 0
for i in range(1, 51) :
    sum += area(i)
print(round(sum))

# ----------------------------------------------------

print('-------------------')
