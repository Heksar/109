#!/usr/bin/python3
import unittest
# --------------------------------------------------------------e101
# Chapter 6 on testing
# --------------------------------------------------------------
# A glass box test suite is path-complete if it tests every path in the code
# Even path-complete test suites may not be sufficient to find all bugs
# ----------------------------------------------------------
def abs(n) :
    '''
    Assume: n is an int
    Returns n if n >= 0 and -n otherwise
    '''
    if n < -1 :
        return -n
    else :
        return n
# --------------------------------------------------------------
# The Testing  {2, -2} is path-complete
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
     self.assertEqual(abs(2), 2)
 def test2(self):
     self.assertEqual(abs(-2), 2)

if __name__ == '__main__':
 unittest.main(exit=True)


# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import random
# ---------------------------------------------------------e102-randint
# Chapter 6 on testing
# --------------------------------------------------------------
# Ideas to discuss briefly:

# unit testing:

# integration testing:

# Software Quality Assurance (SQA):

# test drivers:

# stub: simulates ...

# driver : simulates ...

# Regression testing: 
#
# ----------------------------------------------------------
# Random numbers and Simulation
# Note that random.randint(a, b) will give a pseudorandom number 
# from a to b, inclusive.
# Write a program that prints 1 roll of a die, then 2 rolls, then 3,
# and so on up to 20 rolls.  The output should look something like:
# 5
# 1 4
# 3 2 9
# and so on
# ----------------------------------------------------------
pass



# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import random
# --------------------------------------------------------------e103
# Chapter 6 on testing
# --------------------------------------------------------------
# Ideas to discuss briefly:

# Bug 1947

# no innocence

# Intermittent |             
#              |
#              |
#              |
#              |
#              |
#              |     2-dimensional bug space
#              |
#              |
#              |
#              |
#              |
#              |
#   Persistent |_______________________________________
#              Overt                               Covert
# <1> best
# <2> worse
# <3> worst
# <4> hardest
#
# Examples
# <1> defensive programming:
# <2> air traffic control software
# <3> mortgage bond software
# <4> radiation software
# ----------------------------------------------------------
# Random numbers and Simulation
# Write a program that does an experiment to find how many
# rolls of the die are required before the frequency of each
# number is within 0.01 of 1/6.
# Note: random.randrange(6) gives values from 0 to 5
# ----------------------------------------------------------
# Set up the condition for stopping
# ----------------------------------------------------------
def check(counts, epsilon) :
    '''
    Assume counts is a list of the counts for each possible value 
    on the die: 0 to 5
    Return True if each of the counts is within epsilon of 1/6; False otherwise
    '''
    pass
# ----------------------------------------------------------------------------
# Roll the dice while condition not met
# and count how many 0's, 1's, ..., 5's
# and count how many rolls it takes in all
# ----------------------------------------------------------------------------
pass

# ---------------------------------------------
print('The final array of counts of the various roll values:')
print('----------------------')
print(counts)
print('----------------------')
print('The number of rolls it took to get the count of each value')
print('very close to 1/6 of the total number of rolls:' )
print('----------------------')
print('n = ', n)
print('----------------------')
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import random
import math
# --------------------------------------------------------------e104
# Chapter 6 on testing
# --------------------------------------------------------------
# Ideas to discuss briefly:
# Debugging tools:
# debuggers
# print statement
# Steps
# -------------
# 1. be systematic
# 2. do repeatable experiments
# 3. form hypotheses
# 4. predict
# 5  experiment
# 6. examine
# ----------------------------------------------------------
# Random numbers and Simulation
# ----------------------------------------------------------
# Buffon Needle Experiment:
# drop a one inch needle onto paper that
# is ruled with lines that are 2 inches apart.
# If the needle lands on a line, call that a hit.  Buffon conjectured that
# tries/hits would approximate pi
# Use the random number generator to run this experiment.
# Note: random.uniform(a, b) returns a random floating point number from
# a to b.
# ----------------------------------------------------------
# A random number from 0 to 2 represents the lower end, ylow
# A random number from 0 to 180 represents the angle, alpha
# The high end of the needle is yhigh = ylow + sin(alpha)
# a HIT is where yhigh is at least 2
# Do 10000 tries and get the result of tries/hits
# ----------------------------------------------------------
pass
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import random
import math
# --------------------------------------------------------------e105
# Chapter 6 on testing
# --------------------------------------------------------------
# Ideas to discuss briefly:
# debugging = ...
# bisection: (1)   and (2)
# Approaches:
#   not why not but why is 
#   not where you think
#   explain
#   don't believe
#   write doc
#   walk
#   not quick fix
#   usual suspects:
#     order of args
#     spelling
#     initialization of variables
#     float == float
#     value equality not object equality
#     side effects
#     missing ()
#     alias
# ----------------------------------------------------------
#  Example of bisection search
# ----------------------------------------------------------

# ----------------------------------------------------------
# Checking for palindromic list
# ----------------------------------------------------------
def isPal(L) :
    '''
    Assumes L is a list
    Returns True if L is a palindrome, False otherwise
    '''
    temp = L
    temp.reverse
    if temp == L :
        return True
    else :
        return False
# --------------------------------------------------------------
# Getting elements of the list from the user
# --------------------------------------------------------------
def silly(n) :
    '''
    Assume n is an integer > 
    Gets n inputs from the user.
    Prints 'Yes' if the sequence of inputs is a palindrome
    'No' otherwise.
    '''
    for i in range(n) :
        result = []
        e = input('Enter element: ')
        result.append(e)
    if isPal(result) :
        print('Yes')
    else :
        print('No')
# --------------------------------------------------------------
silly(3)
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import random
import math
# ----------------------------------------------------------e106-2Darray
# Two-dimensional arrays
# --------------------------------------------------------------
# --------------------------------------------------------------
# Make a 2D matrix that looks like
# 0 0 0 0
# 0 0 0 0
# 0 0 0 0
# --------------------------------------------------------------
matrix = [[0 for j in range(4)] for i in range(3)]
pass # use double list comprehension
print(matrix)
pass # use repetition and list comprehension
matrix = [4 * [0] for i in range(3)]
print('-------------repetition and comprehension')
print(matrix)
print('-------------double repetition ')
matrix = 3 * [4 * [0]]
pass # use double repetition
print(matrix)
# Make a 2D matrix that looks like
# 5 9 2 3
# 1 4 7 8
# 1 2 1 2
# --------------------------------------------------------------
pass # put in code to make the matrix
matrix = []
row = [5, 9, 2, 3]
matrix.append(row)
row = [1, 4, 7, 8]
matrix.append(row)
row = [1, 2, 1, 2]
matrix.append(row)
# change the 7 to 107
matrix[1][2] = 107
print(matrix)
# ----------------------------------------------
# Show how to get the number of rows and number of columns
# ----------------------------------------------
rows = numberofrows = len(matrix)
cols = numberofcols = len(matrix[0])
print('---------------------')
print('number of rows is {} and number of columns is {}'.format(rows, cols))
print('---------------------')

# ----------------------------------------------
# Is that always a good way to get the dimensions?
# no since sometimes the length of rows are different
# ----------------------------------------------

# ----------------------------------------------
# Write a function to print the matrix
# ----------------------------------------------
def printmx(m) :
    print('--------------------')
    for row in m :
        print(row)
    pass # code to print row by row on separate lines with []
    print('--------------------')
# ----------------------------------------------
# Print the matrix
# ----------------------------------------------
printmx(matrix)

# ----------------------------------------------------------
# --------------------------------------------------------------
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import random
import math
# -------------------------------------------------------e107-seed
# Two-dimensional arrays
# --------------------------------------------------------------

# --------------------------------------------------------------
# Making a two-dimensional array filled with random numbers
# --------------------------------------------------------------
def makematrix(m, n, limit) :
    '''
    Returns an m x n two-dimensional array of random integers
    from 0 to limit - 1, inclusive
    '''
    random.seed(9)
    matrix = []
    for i in range(m) :
        row = []
        for j in range(n) :
            row.append(random.randrange(limit))
        matrix.append(row)
    return matrix
# --------------------------------------------------------------
# Making a two-dimensional array filled with random numbers
# --------------------------------------------------------------
def makematrix2(m, n, limit) :
    '''
    Returns an m x n two-dimensional array of random integers
    from 0 to limit - 1, inclusive
    '''
    random.seed(1)
    return [[random.randrange(limit) for j in range(n)] for i in range(m)]
# ----------------------------------------------------------
# Make a random 5x3 matrix with random integers from 0 to 50, inclusive
# --------------------------------------------------------------
pass # use makematrix
mx = makematrix(5, 3, 51)
print(mx)
mx2 = makematrix2(5, 3, 51)
print(mx2)
# ----------------------------------------------------------
# Show how the random seed works
# --------------------------------------------------------------
pass

# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import unittest
# --------------------------------------------------------------
# Largest of four values
# --------------------------------------------------------------
def largestoffour(a, b, c, d) :
    '''
    Assume that the four parameters are numbers.
    Return the largest of the four numbers.
    You cannot use the built-in max() function
    You cannot use the built-in sort() function
    For example, if a is 9, and b is 7, and c is 7 and d is 9,
    then the function would return 9.
    '''
    biggest = a
    for value in (b, c, d) :
        if value > biggest :
            biggest = value
    return biggest
# --------------------------------------------------------------
# The Testing
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
  self.assertEqual(largestoffour(1, 2, 3, 4), 4)
 def test2(self):
  self.assertEqual(largestoffour(1, 2, 3, 2), 3)
 def test3(self):
  self.assertEqual(largestoffour(1, 2, 12, 2), 12)
 def test4(self):
  self.assertEqual(largestoffour(22, 12, 1, 9), 22)
 def test5(self):
  self.assertEqual(largestoffour(-2, -12, -19, -1), -1)


if __name__ == '__main__':
 unittest.main(exit=True)




# --------------------------------------------------------------
# The End
# -------------------------------------
#!/usr/bin/python3
import unittest
# --------------------------------------------------------------
# Adding up to the value 'Quit'
# --------------------------------------------------------------
def sumquit(L) :
    '''
    Assume that L is a list where one of the elements is 'Quit'.
    Return the sum of the numbers in L up to the word 'Quit'.
    For example, 
    sumquit(['Quit', 1, 2, 3]) returns 0
    sumquit([1, 2, 3,'Quit']) returns 6
    sumquit([1, 2, 3,'Quit', 4, 5, 9]) returns 6
    '''
    sum = 0
    for value in L :
        if value == 'Quit' :
            return sum
        sum += value
    return sum
# --------------------------------------------------------------
# The Testing
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
  self.assertEqual(sumquit([1, 2, 3, 4, 'Quit']), 10)
 def test2(self):
  self.assertEqual(sumquit([1, 2, 3, 22, 'Quit', 99]), 28)
 def test3(self):
  self.assertEqual(sumquit(['Quit', 11, 2, 2, 22]), 0)
 def test4(self):
  self.assertEqual(sumquit([200, 'Quit', 2, 80, 2]), 200)


if __name__ == '__main__':
 unittest.main(exit=True)




# --------------------------------------------------------------
# The End
# --------------------------------------------------------------

#!/usr/bin/python3
import unittest
# --------------------------------------------------------------
# Sum = 1/1 + 1/2 + 1/3 + ... + 1/n
# --------------------------------------------------------------
def series0(epsilon) :
    '''
    Return the value of n such that the above sum is 
    within epsilon of 4.23.
    For example, 
    if epsilon is 4, then return 1, since 1 the first term is within 4 of 4.23
    if epsilon is 3, then return 2, since 1 + 1/2 = 1.5 is within 3 of 4.23
    '''
    sum = 1
    n = 1
    target = 4.23
    while abs(sum - target) > epsilon :
        n = n + 1
        sum += 1/n
    return n
# --------------------------------------------------------------
# The Testing
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
  self.assertEqual(series0(4), 1)
 def test2(self):
  self.assertEqual(series0(3), 2)
 def test3(self):
  self.assertEqual(series0(1), 14)
 def test4(self):
  self.assertEqual(series0(0.5), 23)
 def test5(self):
  self.assertEqual(series0(0.01), 38)


if __name__ == '__main__':
 unittest.main(exit=True)




# --------------------------------------------------------------
# The End
# --------------------------------------------------------------

#!/usr/bin/python3
import unittest
# --------------------------------------------------------e111-trim-iter
# Trim front and back of string without recursion.
# --------------------------------------------------------------
def trim(S) :
    """
    Assume that S is a string.
    Return a string which is the same as string S, but with 
    no blanks at the front or end of the string.  
    For example trim('   dog   ') returns 'dog'.  
    trim('    cat in the hat') returns 'cat in the hat'.  
    Notice that blanks that are not at the beginning or end are 
    left as they are.  
    Example 3: trim('')  and trim('       ') both return the empty string.  
    You must not use recursion.  
    Do not use built in functions that trim, like rtrim().  
    """
    if len(S) == 0 :
        return S
    while len(S) > 0 and S[0] == ' ' :
        S = S[1:]
    while len(S) > 0 and S[-1] == ' ' :
        S = S[:-1]
    return S
# --------------------------------------------------------------
# The Testing
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
  self.assertEqual(trim('    dog   '), 'dog')
 def test2(self):
  self.assertEqual(trim('    cat in the hat'), 'cat in the hat')
 def test3(self):
  self.assertEqual(trim(''), '')
 def test4(self):
  self.assertEqual(trim('      '), '')
 def test5(self):
  self.assertEqual(trim(' red green  blue  .'), 'red green  blue  .')


if __name__ == '__main__':
 unittest.main(exit=True)




# --------------------------------------------------------------
# The End
# --------------------------------------------------------------

#!/usr/bin/python3
import unittest
# ----------------------------------------------------e112-trim-recur
# Recursion to trim a string to remove blanks front and back.
# --------------------------------------------------------------
def trim(S) :
    '''
    Assume that S is a string.
    Return a string which is the same as string S, but with 
    no blanks at the front or end of the string.  
    For example trim('   dog   ') returns 'dog'.  
    trim('    cat in the hat') returns 'cat in the hat'.  
    Notice that blanks that are not at the beginning or end are 
    left as they are.  
    Example 3: trim('')  and trim('       ') both return the empty string.  
    You must use recursion.  
    Do not use built in functions that trim, like rtrim().  
    '''
    if len(S) == 0 :
        return S
    if S[0] != ' ' and S[-1] != ' ' :
        return S
    if S[0] == ' ' :
        return trim(S[1:])
    if S[-1] == ' ' :
        return trim(S[:-1])
# --------------------------------------------------------------
# The Testing
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
  self.assertEqual(trim('    dog   '), 'dog')
 def test2(self):
  self.assertEqual(trim('    cat in the hat'), 'cat in the hat')
 def test3(self):
  self.assertEqual(trim(''), '')
 def test4(self):
  self.assertEqual(trim('      '), '')
 def test5(self):
  self.assertEqual(trim(' red green  blue  .'), 'red green  blue  .')


if __name__ == '__main__':
 unittest.main(exit=True)




# --------------------------------------------------------------
# The End
# --------------------------------------------------------------

