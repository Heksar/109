# --------------------------------------------------------------------------------
# Outline for Week3 (letures 5 and 6
# --------------------------------------------------------------------------------
# Quick recap of Week 2:
# ---------------------------
# branching if, elif, else
# complexity: constant time, linear time
# strings: concatenation, repetition
# strings: length, indexing, slicing
# input('prompt'), casting int() str()
# while loop, break statement
# ---------------------------
# Quick preview of Week 3:
# ---------------------------
# dir(library), help(function)
# random numbers, exploring
22. 2.4 Example: read 10 integers and print largest odd or message
23. 3.1 Exhaustive Enumeration: finding integer cube root
24. 3.1 Decrementing function for cube root program
25. Why exhaustive enumeration is okay
26. Speed of computer
27. Example: given n, find root and power so that n = root ** power
28. 3.2 For loop ... structure, range function
29. 3.2 Examples of for loops, lazy range
30. 3.2 For Loops : note about range and literal list
31. 3.2 For Loops: weird example of trying to change range
32. 3.2 For Loops: weird example of changing range and index
33. 3.2 for loop: finding integer cube root by exhaustive enumeration
34. 3.2 For Loops: iteration through letters of a string
35. 3.2 For Loops: comma separated numbers, with and without split
36. 3.3 Approximation Solutions and Bisection Search: square root
37. 3.3 Approximation Solutions and Bisection Search: cube root
38. Student solution: finding the largest odd number out of three input values
39. 3.4 Floats and precision
40. 3.4 Binary numbers
41. 3.4 Floats in binary: Significant digits and exponent; decimal 0.1 in binary
42. 3.4 Floats    rounding, and tests for equality
43. 3.5 Newton-Raphson algorithm to find roots of polynomial
#!/usr/bin/python3
# -----------------------------------------------------------------------------------------------e22.py
# 2.4 Example: read 10 integers and print largest odd or message
# ----------------------------------------------finger exercise p. 24
# Ask the user for 10 integers, and
# Use 10 random integers from 0 to 20, inclusive
# print the largest odd number entered.
# If no odd number, then print message to that effect
# Mention: short-circuit evaluation
# ----------------------------------------------------------
#!/usr/bin/python3
# ---------------------------------------------------------------------------------------e23.py
# 3.1 Exhaustive Enumeration  (another Guess and Check algorithm)
# Find the integer cube root of a number
# ----------------------------------------------Finding cube root
# Ask the user for any integer, n, (could be negative)
# try the numbers m = 0, 1, 2, ...
# until m**3 is no longer less than the absolute value of n 
# check what you have when you leave the loop
# ----------------------------------------------------------
#!/usr/bin/python3
# -----------------------------------------------------------------------------------------e24.py
# 3.1 Decrementing function for cube root program
# Argue that the program will always terminate
# no matter what the input:
# In the loop,
# 1. 
# 2. 
# 3. 
# -----------------------------------------------------------
#   decrementing function, p. 26 Guttag
# -----------------------------------------------------------
# To prove that a loop terminates, construct a decrementing function
# -------------------------------------------------------------------
# A decrementing function has the following four properties:
# ------------------------------------------------------------
# 1. It maps some program variables into an integer.
# 2. It starts out > 0 (when the loop is entered)
# 3. When it's value is <= 0, the loop terminates
# 4. Its value decreases every time through the loop.
# ----------------------------------------------------------
# What is a decrementing function for the cube root program?
# -------------------------------------------------------------

# -----------------------------------------------------------
# Re-write the cube root program again, forgetting the line
# m = m + 1
# -------------------------------------------------------------------
# see that it never terminates ... press Control-C or
# use the Stop Program button on your IDE
# ------------------------------------------------------------
# To help find the problem, 
# print the decrementing function in the loop to see if it is decreasing.
# ------------------------------------------------------------

#!/usr/bin/python3
# -------------------------------------------------------------------------------------------------e25.py
# Exhaustive enumeration
# -------------------------------------------------------- p. 26-27 Guttag
# Exhaustive enumeration is a variant of Guess and Check
# -- just try all the possibilities
# Seems stupid, but
# 1. often very effective, and
# 2. easy to understand
# 3. easy to implement
# -------------------------------------------------------------------
# Try e22.py on
# 1957816251
# 7406961012236344616
# ------------------------------------------------------------p. 27
# Modern computers are amazingly fast
# one instruction per nanosecond
# the time for light to travel a foot
# -------------------------------------------------


#!/usr/bin/python3
# ------------------------------------------------------------------------------------------e26.py
# Showing the computer can count quickly
# ------------------------------------------------------------
# Write the following program:
# ------------------------------------------------------------
# Ask the user for a big integer N
# A loop that counts up to N
# Print N
# -----------------------------------------------
# See how big N has to be before you notice a pause
# -----------------------------------------------
N = int(input("N, a big positive integer: "))
m = 0
while m < N :
    m = m + 1
print('Done counting to', m)
# -----------------------------------------------
# What is the decrementing function F for this loop?
# Recall:
# 1. F(m, n) is an integer and is nonnegative when loop is entered
# 2. When F(m, n) is <= 0 the loop terminates
# 3. F(m, n) decreases by 1 each iteration
# --------------------------------------------------
# F(m, n) = N - m
# --------------------------------------------------


#!/usr/bin/python3
# ------------------------------------------------------------------------------------------------e27.py
# Finger exercise, p.27
# ------------------------------------------------------------
# Write a program that asks the user for an integer and prints
# two integers, root and power, such that 1 < power < 6
# and root ** power is equal to the integer entered by the user.
# If no such pair of integers exists, it should print a message
# to that effect.
# (Try 115856201)
# ------------------------------------------------------------


#!/usr/bin/python3
# ----------------------------------------------------------------------------------------------e28.py
# 3.2 For Loops
# ------------------------------------------------------------
# Most of the while loops that we wrote 
# were controlled by an increasing integer sequence, like
i = 0
while i < 5 :
    print(i)
    i = i + 1
# This is so common that Python has a special loop to do that
for i in range(5) :
    print(i)
# The for loop has the structure:
# for variable in sequence :
#    code block
# ----------------------------------------------------------
# the sequence is usually generated by the range function
# range(start, stop, step)
# where start defaults to 0
# and step defaults to 1
# Try out range with some examples:
# range(7), range(1, 7), range(0, 7, 2), range(10, 0, -1)
# -----------------------------------------------------------------


#!/usr/bin/python3
# -----------------------------------------------------------------------------------------------e29.py
# 3.2 For Loops
# ------------------------------------------------------------
# Write some simple printing for loops using range
# ------------------------------------------------------------
# Write some simple printing for loops using an explicit sequence
# Note that [5, 3, 1] is a literal list
# ------------------------------------------------
# Note that range is 'lazy' to save space
# ----------------------------------------------------------
a = [ 5, 3, 1, 9]
for number in a :
    print('number = ', number)
print('----------')



#!/usr/bin/python3
# --------------------------------------------------------------------------------------------e30.py
# 3.2 For Loops : note about range and literal list
# ------------------------------------------------------------
# Note: the arguments to the range function are evaluated just once
# on entering the loop
# Explain results of
n = 10
for i in range(n) :
    print(i, 'n =', n)
    n = 5
# ------------------------------------------------------------
# Write some simple printing for loops using an explicit sequence
# Note that [5, 3, 1] is a literal list
# ------------------------------------------------
# Note that range is 'lazy' to save space
# In the following, a huge list is not created by range()
# ----------------------------------------------------------


#!/usr/bin/python3
# -----------------------------------------------------------------------------------------------e31.py
# 3.2 For Loops: weird example of trying to change range
# ------------------------------------------------------------
# Note: the arguments to the range function are evaluated just once
# on entering the loop
# Explain results of
n = 5
for i in range(n) :
    for j in range(n) :
        print(i, j)
        n = 2
# ------------------------------------------------------------
# Note, this is just an oddity to be aware of, but don't do it.
# -----------------------------------------------------------
#!/usr/bin/python3



# --------------------------------------------------------------------------------------------------e32.py
# 3.2 For Loops: weird example of changing range and index
# ------------------------------------------------------------
# Note: the arguments to the range function are evaluated just once
# on entering the loop
# Explain results of
n = 5
for i in range(n) :
    for j in range(n) :
        print(i, j)
        n = 2
        i = 5
# ------------------------------------------------------------
# Can you guess this output?
# ------------------------------------------------------------
# Note, this is just an oddity to be aware of, but don't do it.
# -----------------------------------------------------------



#!/usr/bin/python3
# -------------------------------------------------------------------------------------------------------e33.py
# 3.2 For Loops: finding integer cube root using for loop and exhaustive enumeration
# ------------------------------------------------------------
# Find the cube root of a perfect cube, using the for loop
# ------------------------------------------------------------



#!/usr/bin/python3
# ---------------------------------------------------------------------------------------------------e34.py
# 3.2 For Loops: iteration through letters of a string
# ------------------------------------------------------------
# Find the sum of the integers in '123456789'
# ------------------------------------------------------------


# ------------------------------------------------------------
    
#!/usr/bin/python3
# -----------------------------------------------------------------------------------------------e35.py
# 3.2 For Loops: comma separated numbers, with and without split
# ------------------------------------------------------------
# Finger exercise p. 30
# ------------------------------------------------------------
'''
Let s be a string that contains a sequence of decimal numbers
separated by commans, e.g., s = '1.23,2.4,43.323'.  Write a program 
that prints the sum of the numbers in s.
'''
# ------------------------------------------------------------


#!/usr/bin/python3
# ----------------------------------------------------------------------------------------------e36.py
# 3.3 Approximation Solutions and Bisection Search: square root
# ------------------------------------------------------------
# Finding the square root of a number by exhaustive enumeration
# takes too long
# ------------------------------------------------------------
# Bisection search is the way we look up a word in a paper dictionary.
# ------------------------------------------------------------
# Assume that you know the root, sqrt(x) is between low = 0 and high
# and you guess in the middle:
# ------------------------------------------------------------
# low                        guess                          high
# -------------------------------------------------------------
# Now you can square guess to see if guess is
# close enough -> stop
# too low ->      make a new guess after moving low to guess
# too high ->     make a new guess after moving high to guess
# -----------------------------------------------------------------
# Write the program for finding sqrt(x) using bisection search
# Note: high starts as x or 1.0, whichever is bigger
# --------------------------------------------------------------
x = 25
low = 0
high = max(1.0, x)









print(guess, 'is a close approximation to the square root of', x)
print(count, 'guesses')
# ---------------------------------------------------------------



#!/usr/bin/python3
# ------------------------------------------------------------------------------------------------e37.py
# 3.3 Approximation Solutions and Bisection Search: cube root
# ------------------------------------------------------------
# p. 34 Finger exercise:
# 1. What happens in e36 if x = -25?
# ------------------------------------------------------------
# 2. Modify the square root code to do cube root
#    and so that it works with negative numbers.
#    Hint: modify the low variable.
# -----------------------------------------------------------------


#!/usr/bin/python3
# -------------------------------------------------------------------------------------------------e38.py




#!/usr/bin/python3
# --------------------------------------------------------------------------------------------------e39.py
# 3.4 Floats and precision
# ------------------------------------------------------------
# Write a for loop to add 0.1 to sum 10 times and print the result
# ------------------------------------------------------------
# Why is the result not 1?
# -----------------------------------------------------------------



#!/usr/bin/python3
# ----------------------------------------------------------------------------------------------------e40.py
# 3.4 Binary numbers
# ------------------------------------------------------------
# Review the meaning of 1301 in base 10 (decimal)
# ------------------------------------------------------------
# Explain counting in binary numbers
# Why does computer use binary?
# -----------------------------------------------------------------
# What is 10011 base 2 when represented in decimal?



#!/usr/bin/python3
# --------------------------------------------------------------------------------------------------e41.py
# 3.4 Floats in binary: Significant digits and exponent; decimal 0.1 in binary
# ------------------------------------------------------------
# Explain: 
# decimal 2.432 is what pair? (signicant digits, exponent) =
# (  )
# Explain precision
# Explain rounded value
# decimal 0.625 is 5/8, so what is the binary pair (significant, exponent)?
# (       )
# What about 1/10, using 4 significant bits
# (           )
# 53 bits of precision has the following significant digits for 0.1
# 11001100110011001100110011001100110011001100110011001
# which results in (barring typos)
# 0.100000000000000005551115123125782702118158340451015625
# ------------------------------------------------------------



#!/usr/bin/python3
# -------------------------------------------------------------------------------------------------e42.py
# 3.4 Floats    rounding, and tests for equality
# ------------------------------------------------------------
# round(x, numDigits) rounds x to numDigits after decimal point
# ------------------------------------------------------------
# round(2 ** 0.5, 3) is: _________
# ------------------------------------------------------------
# abs(x - y) < epsilon  is better than x == y
# ----------------------------------------------------------
# sometimes watch for accumulation of rounding errors.
# ----------------------------------------------------------



#!/usr/bin/python3
# --------------------------------------------------------------------------------------------------e42.py
# 3.5 Newton-Raphson algorithm to find roots of polynomial
# ------------------------------------------------------------
# finding the roots of a polynomial, like p(x) = 3x^2 + 4x + 7
# ------------------------------------------------------------
# degree of polynomial is the largest degree of any term, so 2 above.
# ------------------------------------------------------------
# p(r) means the value of p when x = r
# ------------------------------------------------------------
# The root of the polynomial p is r where p(r) is 0
# ------------------------------------------------------------
# Finding square root of 24 is solving for root of p(x) = x^2 - 24 = 0
# ------------------------------------------------------------
