# Programs developed in class on Nov. 3 and Nov. 6, 2020

#!/usr/bin/python3
import copy
# ----------------------------------------------------------e92-copy.py
# Chapter 5.3.1: lists and cloning
# ------------------------------------------------------------
# How to clone, list A
# ------------------------------------------------
# clone by slicing B = A[:]
# ------------------------------------------------
# clone by list()    B = list(A)
# ------------------------------------------------
# not clone by alias  not B = A
# ------------------------------------------------
# deep clone by copy.deepcopy()
# after importing copy
# ------------------------------------------------
M = ['red', 'green', 'blue']
L = [1, 2, 3, M]
N = L[:]   # does N have a different id from L?
P = copy.deepcopy(L)
print(L, id(L))
print(N, id(N))
print(P, id(P))
print(M, id(M))
print('L[3]:', id(L[3]))  # same as id of M  so L[3] is an alias of M
print('N[3]:', id(N[3])) # same as id of M
print('P[3]:', id(P[3]))  # same as id of nothing else
#!/usr/bin/python3
# ----------------------------------------------------------e92-deepcopy.py
# Chapter 5.3.1: lists and cloning
# ------------------------------------------------------------
# Exercise: make a deep copy of a list
def copy2(L) :
    '''
    Assume L is a list.
    Make and return a deep copy of L, without using slice or list() or 
    copy.deepcopy()
    '''
    #base case
    if len(L) == 0 :
        return []
    # general case
    e = L[0]
    if type(e) == list :
        return [copy2(e)] + copy2(L[1:])
    else :
        return [e] + copy2(L[1:])
# Try it out
L2 = ['a', 'b', 'c']
L3 = [9, 10, L2]
L1 = [1, 2, 3, L3, 'def']
L4 = copy2(L1)
print(L1, 'original')
print(L4, 'deep copy')
print('---------------------------')
print('How could you prove that L2 is a deep copy?')
print('---------------------------')
#!/usr/bin/python3
# ----------------------------------------------e93-comprehension.py
# Chapter 5.3.2: list comprehension
# concise way to make a list
# ------------------------------------------------------------
# Exercise: make a list of squares of even values from 0 to 20
# ------------------------------------------------------------
L = []
for i in range(0, 21, 2) :
    L.append(i ** 2)
print('L: ', L)
# ------------------------------------------------------------
# Do the same with list comprehension
# -------------------------------------------------------------
L2 = [i ** 2 for i in range(0, 21,2)]
print('L2: ', L2)
# ------------------------------------------------------------
# Do the the list comprehension skipping elements that are not int
# -------------------------------------------------------------
M = [2, 4, 'six', 8.0, 10]
L3 = [x for x in M if type(x) == int]
print('L3: ', L3)
# ------------------------------------------------------------
# Show three ways to make a list of 50 0's
# -------------------------------------------------------------
A1 = []
for i in range(50) :
    A1.append(0)
A2 = [0 for i in range(50)]
A3 = 50 * [0]
print(A1)
print(A2)
print(A3)
#!/usr/bin/python3
# -----------------------------------------------------e94-functions.py
# Chapter 5.4 Functions as objects
# ------------------------------------------------------------
# What are objects? things that the program manipulates
# ------------------------------------------------------------
# Name some objects: 'abc', ['a', 'b', 'c'], 1, 2, 3.4, (9, 7), sqrt
# ------------------------------------------------------------
# What can one do with an object?
# assign it to a variable  (i.e., bind the variable to the object)
# argument ... object can be an argument to a function
# type     ... type(object)
# expression ... put it in an expression
# element    ... put it in a tuple or list
# ------------------------------------------------------------
# Exercise:
# -------------------------------------------------------------
def apply(f, L) :
    '''
    Assume f is a function and L is a list.
    Mutate L by applying f to each of its elements.
    '''
    for i in range(len(L)) :
        L[i] = f(L[i])
# ------------------------------------------------------------
# Try it out
L = [1, -2, 3, -5]
apply(abs, L)
K = [1, -2, 3, -5]
apply(str, K)
print('after applying abs to L, L is: ', L)
print('after applying str to K, L is: ', K)
# ------------------------------------------------------------
# Exercise: do the same without using higher order programming
def applyAbs(L) :
    for i in range(len(L)) :
        L[i] = abs(L[i])
    
# -------------------------------------------------------------
# Use apply with fact, fib, int, str to see the advantage
# ------------------------------------------------------------
# Look briefly at map()
# map is more general than apply
X = [5, 9, 100, 3, 7]
Y = [3, 19, 10, 3, 77]
print('---------------------')
for value in map(min, X, Y) :
    print(value)
print(list(map(min, X, Y)))
print(map(min, X, Y))
print(range(1, 10))
#!/usr/bin/python3
# ----------------------------------------------------e95-dict.py
# Chapter 5.5 Similarities among String, Tuple, List, Range
#         TLDR;
#             and some more functions
#   Please read that section on your own.
# ------------------------------------------------------------
# Chapter 5.6 Dictionary
# ------------------------------------------------------------
# dictionaries are key-value pairs
# L[3]  with a list
# B['cat']
# ------------------------------------------------------------
# a dictionary is an object of type dict
# ------------------------------------------------------------
# a literal of type dict is written with braces
# where each element looks like
# key : value
# --------------------------------------------------
monthnumbers = {'Jan' : 1, 'Feb' : 2, 'Mar' : 3, 'Apr' : 4, 'May': 5} 
# --------------------------------------------------
# Show how to iterate through the keys
# --------------------------------------------------
for month in monthnumbers :
    print(month, monthnumbers[month])
print('----------------------------')
# --------------------------------------------------
# Show that a dictionary is mutable by adding aother element
# --------------------------------------------------
monthnumbers['June'] = 6
# -----------------------------------------------
# Note: that the order in which the keys appear is not defined.
# Note: key search is efficient because of hashing
# -----------------------------------------------
print(monthnumbers)



#!/usr/bin/python3
# --------------------------------------------------------------e96-dictCat
# 
# --------------------------------------------------------------
# Read a file catinhat.txt, and count how many different words
# and what is the most frequent word
# ----------------------------------------------------------
f = open('catinhat.txt')
words = f.read()
words = words.lower()
#print(words)
punctuation = "!',,."
for letter in punctuation :
    words = words.replace(letter, '')
L = words.split()
#print(L)

count = {}
for word in L :
    if word in count :
        count[word] += 1
    else :
        count[word] = 1
print('largest key is', max(count))

maxkey = None
maxcount = 0
for key in count.keys() :
    if count[key] > maxcount :
        maxkey = key
        maxcount = count[key]
print('maxkey =', maxkey, 'maxcount = ', maxcount)
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e96-dictMethods
# Chapter 5.6 Dictionary
# ------------------------------------------------------------
# Useful operations on dictionary d
# where k means key, and v means value
# ------------------------------------------------------------
# len(d)
# ------------------------------------------------------------
# d.keys()
# ------------------------------------------------------------
# d.values()
# ------------------------------------------------------------
# k in d
# ------------------------------------------------------------
# d.get(k, v)
# ------------------------------------------------------------
# d[k]
# ------------------------------------------------------------
# d[k] = v
# ------------------------------------------------------------
# del d[k]
# ------------------------------------------------------------
# for k in d :
# ------------------------------------------------------------
birthstones = {'Jan' : 'Garnet', 'Feb' : 'Amethyst', 'Mar' : 'Acquamarine',
               'Apr' : 'Diamond', 'May' : 'Emerald'}
print('birthstones:', birthstones)
a = 'blue'
#print(birthstones[a])     bad exception
print(birthstones.get(a, 'sky'))



#!/usr/bin/python3
import unittest
# --------------------------------------------------------------e97-testSpecs
# Chapter 6 on testing, but 
# mixing in some other questions
# --------------------------------------------------------------
# What can testing reveal?  ____________________
# What is black box testing? __________________
# What is glass box testing? __________________
# --------------------------------------------------------------
def mostfrequent(L) :
    '''
    Assume that L is a non-empty list.
    Return the number which is most frequent in the list.
    For example, 
    mostfrequent([5, 2, 9, 2, 9, 1, 18, 9, 3]) would return 9, since 
    there are three 9's, and two 2's, and one of other values.
    '''
    return 100
    pass
# --------------------------------------------------------------
# The Testing
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
  self.assertEqual(mostfrequent([5, 2, 9, 2, 9, 1, 18, 9, 3]), 9)
 def test2(self):
  self.assertEqual(mostfrequent(['cat', 'dog', 'dog', 'cat', 'cat']), 'cat')
 def test3(self):
  self.assertEqual(mostfrequent([5]), 5)
 def test4(self):
  self.assertEqual(mostfrequent([1, 2, 3, 3, 2, 1]), 2)
 def test5(self):
  self.assertEqual(mostfrequent([(5, 5, 5), (3, 2, 1), (5, 5, 5)]), (5, 5, 5))


if __name__ == '__main__':
 unittest.main(exit=True)

# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import unittest
# --------------------------------------------------------------e97-testSpecs
# Chapter 6 on testing
# --------------------------------------------------------------
# What can testing reveal?  _________presence of errors
# What is black box testing? ________testing without looking at code
# What is glass box testing? ________testing after looking at code
# --------------------------------------------------------------
def mostfrequent(L) :
    '''
    Assume that L is a non-empty list.
    Return the element which is most frequent in the list.
    For example, 
    mostfrequent([5, 2, 9, 2, 9, 1, 18, 9, 3]) would return 9, since 
    there are three 9's, and two 2's, and one of other values.
    In the case of more than one element being most frequent,
    return the first most frequent element
    '''
    count = {}
    for element in L :
        if element in count :
            count[element] += 1
        else :
            count[element] = 1
    maxcount = 0
    maxkey = None
    for key in count.keys() :
        if count[key] > maxcount :
            maxcount = count[key]
            maxkey = key
    return maxkey

# --------------------------------------------------------------
# The Testing
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
  self.assertEqual(mostfrequent([5, 2, 9, 2, 9, 1, 18, 9, 3]), 9)
 def test2(self):
  self.assertEqual(mostfrequent(['cat', 'dog', 'dog', 'cat', 'cat']), 'cat')
 def test3(self):
  self.assertEqual(mostfrequent([5]), 5)
 def test4(self):
  self.assertEqual(mostfrequent([1, 2, 3, 3, 2, 1]), 1)
 def test5(self):
  self.assertEqual(mostfrequent([(5, 5, 5), (3, 2, 1), (5, 5, 5)]), (5, 5, 5))


if __name__ == '__main__':
 unittest.main(exit=True)




# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import unittest
# -----------------------------------------------------e98-testPartitions
# Chapter 6 on testing
# --------------------------------------------------------------
# What is a partition: ___a division of the inputs into subsets
#     where every element is in exactly one subset
#
# Possible partitions for the question below
#       x                  y
#   positive              positive
#   positive              negative
#   negative              positive
#   negative              negative
#       0                   0
#       0                   not 0
#     not 0                 0
# ------------------------------------------------------
# Finding good partitions can be difficult
# look at paths through the specifications and paths through the code
# --------------------------------------------------------------
def isSmaller(x, y) :
    '''
    Assume that x, y are integers
    Return True if x is less than y, False otherwise
    '''
    return x < y 
# --------------------------------------------------------------
# The Testing   Fill in the following by the partitions
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
  self.assertEqual(isSmaller(3, 9), True)
 def test2(self):
  self.assertEqual(isSmaller(3, -9), False)
 def test3(self):
  self.assertEqual(isSmaller(-3, 9), True)
 def test4(self):
  self.assertEqual(isSmaller(-3, -9), False)
 def test5(self):
  self.assertEqual(isSmaller(0, 0), False)
 def test6(self):
  self.assertEqual(isSmaller(0, 9), True)
 def test7(self):
  self.assertEqual(isSmaller(9, 0), False)

if __name__ == '__main__':
 unittest.main(exit=True)


# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import unittest
# --------------------------------------------------------------e99-testBCs
# Chapter 6 on testing
# --------------------------------------------------------------
# Black box testing explores paths through: specifications
#
# Glass box testing explores paths through: the code itself
# ----------------------------------------------------------
# What are boundary conditions? edge cases
# boundary conditions for list: empty list, one element, list element in list
# boundary conditions for numbers: typical numbers, negative, 0, very small, very large
# --------------------------------------------------------------
def sqrt(x, epsilon) :
    '''
    Assume: x, epsilon are floating point numbers
    x >= 0
    epsilon > 0
    Returns y such that
    x - epsilon <= y * y <= x + epsilon
    '''
    guess = x   / 2
    while (abs(guess**2 - x) > epsilon) :
        guess = (guess + x / guess) / 2
    return guess
# --------------------------------------------------------------
# The Testing   Try the boundary conditions for numbers
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
     self.assertEqual(sqrt(0.0, 0.0001), 0.0)
 def test2(self):
     x, epsilon  = 25.0, 0.0001   # typical case
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)
 def test3(self):
     x, epsilon  = 0.5, 0.0001    # x < 1
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)
 def test4(self):
     x, epsilon  = 2.0, 0.0001   # x having an irrational sqrt
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)
 def test5(self):
     # try 64
     x, epsilon  = 2.0, 1.0 / 2.0 ** 32  # regular x, very small epsilon
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)
 def test6(self):
     # try 64
     x, epsilon  = 2.0 ** 32, 1.0 / 2.0 ** 32
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)
 def test7(self):
     # try 64
     x, epsilon  = 2.0 ** 32, 2.0 ** 32
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)

if __name__ == '__main__':
 unittest.main(exit=True)


# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import unittest
# --------------------------------------------------------------e100
# Chapter 6 on testing
# --------------------------------------------------------------
# Black box testing should never be skipped, but you also need ..
# Glass box testing can show where a test might be useful
# ----------------------------------------------------------
def isprime(n) :
    '''
    Assume: n is nonnegative integer
    Return True if n is prime, False otherwise
    '''
#    if n <= 2 :
    if n < 2 :
        return False
    for i in range(3, n) :
        if n % i == 0 :
            return False
    return True
# --------------------------------------------------------------
# The Testing
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
     self.assertFalse(isprime(10))
 def test2(self):
     self.assertTrue(isprime(3))
 def test3(self):
     self.assertTrue(isprime(2))

if __name__ == '__main__':
 unittest.main(exit=True)


# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
