# ----------------------------------------------------------
#     Outline for Week 4, lectures 7 and 8
# ----------------------------------------------------------

# ----------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e36.py
# 3.3 Approximation Solutions and Bisection Search: square root
# ------------------------------------------------------------
# Finding the square root of a number by exhaustive enumeration
# takes too long
# ------------------------------------------------------------
# Bisection search is the way we look up a word in a paper dictionary.
# ------------------------------------------------------------
# Assume that you know the root, sqrt(x) is between low = 0 and high
# and you guess in the middle:
# ------------------------------------------------------------
# low                        guess                          high
# -------------------------------------------------------------
# Now you can square guess to see if guess is
# close enough -> stop
# too low ->      make a new guess after moving low to guess
# too high ->     make a new guess after moving high to guess
# -----------------------------------------------------------------
# Write the program for finding sqrt(x) using bisection search
# Note: high starts as x or 1.0, whichever is bigger
# Try
# x = 0.25
# x = 25
# --------------------------------------------------------------
# ---------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e37.py
# 3.3 Approximation Solutions and Bisection Search: cube root
# ------------------------------------------------------------
# p. 34 Finger exercise:
# 1. What happens in e36 if x = -25?
# ------------------------------------------------------------
# 2. Modify the square root code to do cube root
#    and so that it works with negative numbers.
#    Hint: modify the low variable.
# Try
# x = 0.25
# x = -25
# -----------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e39.py
# 3.4 Floats and precision
# ------------------------------------------------------------
# Write a for loop to add 0.1 to sum 10 times and print the result
# ------------------------------------------------------------
# Why is the result not 1?
# -----------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e40.py
# 3.4 Binary numbers
# ------------------------------------------------------------
# Review the meaning of 1301 in base 10 (decimal)
# ------------------------------------------------------------
# Explain counting in binary numbers
# Why does computer use binary?
# -----------------------------------------------------------------
# What is 10011 base 2 when represented in decimal?
#!/usr/bin/python3
# ----------------------------------------------------------e41.py
# 3.4 Floats in binary: Significant digits and exponent; decimal 0.1 in binary
# ------------------------------------------------------------
# Explain: 
# decimal 2.432 is what pair? (signicant digits, exponent) =
# (  )
# Explain precision
# Explain rounded value
# decimal 0.625 is 5/8, so what is the binary pair (significant, exponent)?
# (       )
# What about 1/10, using 4 significant bits or 5 significant bits
# 4 signif bits: (           ) = 3/32 = 0.09375
# 5 signif bits: (           ) = 25/256 = 0.09765625
# (           )
# 53 bits of precision has the following significant digits for 0.1
# 11001100110011001100110011001100110011001100110011001
# which results in
# 0.100000000000000005551115123125782702118158340451015625
# ------------------------------------------------------------

#!/usr/bin/python3
# ----------------------------------------------------------e42.py
# 3.4 Floats    rounding, and tests for equality
# ------------------------------------------------------------
# round(x, numDigits) rounds x to numDigits after decimal point
# ------------------------------------------------------------
# round(2 ** 0.5, 3) is: _________
# ------------------------------------------------------------
# abs(x - y) < epsilon  is better than x == y
# ----------------------------------------------------------
# sometimes watch for accumulation of rounding errors.
# ----------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e42.py
# 3.5 Newton-Raphson algorithm to find roots of polynomial
# ------------------------------------------------------------
# finding the roots of a polynomial, like p(x) = 3x^2 + 4x + 7
# ------------------------------------------------------------
# degree of polynomial is the largest degree of any term, so 2 above.
# ------------------------------------------------------------
# p(r) means the value of p when x = r
# ------------------------------------------------------------
# The root of the polynomial p is r where p(r) is 0
# ------------------------------------------------------------
# Finding square root of 24 is solving for root of p(x) = x^2 - 24 = 0
# ------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e44.py
# 3.5 Newton-Raphson  or Newton method
# ------------------------------------------------------------
# Use the Newton-Raphson method to calculate the square root of 24
# to the accuracy that abs(root ** 2 - 24) < epsilon = 0.01
# ------------------------------------------------------------


# -------------------------------------------------------------
#!/usr/bin/python3


# ----------------------------------------------------------e45.py
# 3.5 Newton-Raphson  or Newton method -- 3
# ------------------------------------------------------------
# Use the Newton-Raphson method to calculate the cube root of 24
# to the accuracy that abs(root ** 3 - 24) < epsilon = 0.01
#
# p(x) = x**3 - k         where k is 24
# p'(x) = 
# if guess is g, next guess is g - p(g)/p'(g)
#            which is:         
# ------------------------------------------------------------
# copy in the previous program for square root and modify it.
# -------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e46.py
# 3.5 Newton-Raphson  or Newton method  -- 4
# ------------------------------------------------------------
# Use the Newton-Raphson method to calculate the fourth root of 24
# to the accuracy that abs(root ** 4 - 24) < epsilon = 0.01
#
# p(x) = x**4 - k         where k is 24
# p'(x) = 
# if guess is g, next guess is g - p(g)/p'(g)
#            which is:         
# ------------------------------------------------------------
# Try to write the program yourself from scratch
# 1. start with a guess
# 2. run a while loop until the error gets small enough
#    where you improve the guesses using g - p(g)/p'(g)
# 3. print the answer
# -------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e47.py
# 3.5 Newton-Raphson  or Newton method -- 5
# ------------------------------------------------------------
# Use the Newton-Raphson method to calculate the fifth root of 24
# to the accuracy that abs(root ** 5 - 24) < epsilon = 0.01
#
# p(x) = x**5 - k         where k is 24
# p'(x) = 
# if guess is g, next guess is g - p(g)/p'(g)
#            which is:         
# ------------------------------------------------------------
# Try to write the program yourself from scratch
# 1. start with a guess
# 2. run a while loop until the error gets small enough
#    where you improve the guesses using g - p(g)/p'(g)
# 3. print the answer
# -------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e48.py
# 3.5 Newton-Raphson  or Newton method -- n
# ------------------------------------------------------------
# Use the Newton-Raphson method to calculate the nth root of 24
# to the accuracy that abs(root ** n - 24) < epsilon = 0.01
#
# p(x) = x**n - k         where k is 24
# p'(x) = 
# if guess is g, next guess is g - p(g)/p'(g)
#            which is:         
# ------------------------------------------------------------
# Try to write the program yourself from scratch
# 0. Read n from the user
# 1. Make a guess
# 2. Run a while loop until the error gets small enough
#    where you improve the guesses using g - p(g)/p'(g)
# 3. print the answer
# -------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e49.py
# Review: a problem from the TA (Tony Misic)
# ------------------------------------------------------------
'''
Write a program that takes a value n from the user (using the function input()).
Loop from 1 to n inclusively and for each iteration print out
   'FIZZ' if the iteration is divisible by 3,
   'BUZZ' if the iteration is divisible by 5,
   'FIZZBUZZ' if the iteration is divisible by 3 and 5,
   otherwise print the iteration.
'''
# -------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e50.py
# Review: a problem from the TA (Jae)
# ------------------------------------------------------------
# Question: Given any smaller and larger number 
# count even and odd numbers in the range, inclusive,
# using loop and if statement
# ------------------------------------------------------------
# -------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e51.py
# Review: a problem from the TA (Tony Huynh)
# ------------------------------------------------------------
# Question: 
#   Using a loop, print the sum of all integers between 0 and 50 (inclusive).
# ------------------------------------------------------------






# -------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e52.py
# Review: a problem from the TA (Tony Huynh)
# ------------------------------------------------------------
# Question: 
#   Using a loop, print the sum of all even integers between 0 and 50 (inclusive).
# ------------------------------------------------------------


# -------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e53.py
# Chapter 4: Functions, scoping, abstraction
# ------------------------------------------------------------
# What we covered so far:
# numbers, operators, assignments, if statements, loops, input/output
# is enough to make the language Turing Complete
# ------------------------------------------------------------
# If a language is Turing Complete,
# what can it do:
# what can it not do:
# ------------------------------------------------------------
# Nevertheless, it is important to have functions, e.g., abs(), max()
# Why?
# 1.
# 2.
# 3. 
# -------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e54.py
# Chapter 4: Functions: format and example, maxval()
# ------------------------------------------------------------
# def functionname(list of formal parameters) :
#    body of function
# -------------------------------------------------------------
# Write the function maxval(x, y)
# -------------------------------------------------------------





# -------------------------------------------------------------
# What are the formal parameters:
# What are the actual parameters:
# What are the arguments to the function:
# Function invocation:
# Calling the function:
# maxval(3, 4) binds what to what?
# -------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e55.py
# Chapter 4: Functions: dynamics, example areaOfCircle()
# ------------------------------------------------------------
# Write a function to compute the area of a circle
# -------------------------------------------------------------


# -----------------------------------------------------------------
# Talk about:
# return statement:
# 1. Can you use return in a loop?  Try it.
# 2. A function call is an expression
# 3. A function call has a value -- what is the value of areaOfCircle(3)?
# -----------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e56.py
# Chapter 4: Functions: return value, example hello()
# ------------------------------------------------------------
# Write a function to print Hello, with no parameters
# -------------------------------------------------------------


# -----------------------------------------------------------------
# Talk about:
# return statement:
# 1. A function call is an expression
# 2. A function call has a value -- what is the value of hello()
# 3. If there is no return statement, then when does the function end?
# -----------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e57.py
# Chapter 4: Functions: return value, example bye()
# ------------------------------------------------------------
# Write a function to print Goodbye, with no parameters, and a return statement.
# -------------------------------------------------------------


# -----------------------------------------------------------------
# Talk about:
# return statement:
# 1. A function call is an expression and therefore has a value
# -----------------------------------------------------------------
# 2. What is the value of bye()
# -----------------------------------------------------------------
#    Point of execution is the next instruction to be executed.
# 3. When the function ends, to where is the point of execution transferred?
# -----------------------------------------------------------------

# ----------------------------------------------------------e58.py
# Chapter 4: Functions: binding of formal parameters, example hello(name)
# ------------------------------------------------------------
# Write a function to return string "Hello X", where X is the given name
# -------------------------------------------------------------
def hello(first, last, reverse = False) :


# -----------------------------------------------------------------
# Talk about:
# default formal parameters
# return statement:
# 1. A function call is an expression and therefore has a value
# -----------------------------------------------------------------
# 2. What is the value of hello("Sadaf" + " Mustafiz")
# -----------------------------------------------------------------
# 3. What gets bound to what?
# -----------------------------------------------------------------

