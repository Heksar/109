#!/usr/bin/python3
import copy
# ----------------------------------------------------------e92-copy.py
# Chapter 5.3.1: lists and cloning
# ------------------------------------------------------------
# How to clone
# ------------------------------------------------
# clone by slicing
# ------------------------------------------------
# clone by list()
# ------------------------------------------------
# not clone by alias
# ------------------------------------------------
# deep clone by copy.deepcopy()
# after importing copy
# ------------------------------------------------
M = ['red', 'green', 'blue']
L = [1, 2, 3, M]
N = L[:]
P = copy.deepcopy(L)
print(L, id(L))
print(N, id(N))
print(M, id(M))
print('L[3]:', id(L[3]))
print('N[3]:', id(N[3]))
print('P[3]:', id(P[3]))
#!/usr/bin/python3
# ----------------------------------------------------------e92-deepcopy.py
# Chapter 5.3.1: lists and cloning
# ------------------------------------------------------------
# Exercise: make a deep copy of a list
def copy2(L) :
    '''
    Assume L is a list.
    Make and return a deep copy of L, without using slice or list() or 
    copy.deepcopy()
    '''
    pass
# Try it out
L2 = ['a', 'b', 'c']
L3 = [9, 10, L2]
L1 = [1, 2, 3, L3, 'def']
L2 = copy2(L1)
print(L1, 'original')
print(L2, 'deep copy')
print('---------------------------')
print('How could you prove that L2 is a deep copy?')
print('---------------------------')
#!/usr/bin/python3
# ----------------------------------------------e93-comprehension.py
# Chapter 5.3.2: list comprehension
# concise way to make a list
# ------------------------------------------------------------
# Exercise: make a list of squares of even values from 0 to 20
# ------------------------------------------------------------

# ------------------------------------------------------------
# Do the same with list comprehension
# -------------------------------------------------------------


# ------------------------------------------------------------
# Do the the list comprehension taking skipping elements that are not int
# -------------------------------------------------------------
M = [2, 4, 'six', 8.0, 10]


# ------------------------------------------------------------
# Show two ways to make a list of 50 0's
# -------------------------------------------------------------
#!/usr/bin/python3
# -----------------------------------------------------e94-functions.py
# Chapter 5.4 Functions as objects
# ------------------------------------------------------------
# What are objects? 
# ------------------------------------------------------------
# Name some objects
# ------------------------------------------------------------
# What can one do with an object?
# assign it to a variable  (i.e., bind the variable to the object)
# argument ... object can be an argument to a function
# type     ... type(object)
# expression ... put it in an expression
# element    ... put it in a tuple or list
# ------------------------------------------------------------
# Exercise:
# -------------------------------------------------------------
def apply(f, L) :
    '''
    Assume f is a function and L is a list.
    Mutate L by applying f to each of its elements.
    '''
    pass
# ------------------------------------------------------------
# Try it out
L = [1, -2, 3, -5]
apply(abs, L)
print('after applying abs to L, L is: ', L)
# ------------------------------------------------------------
# Exercise: do the same without using higher order programming
# -------------------------------------------------------------
# Use apply with fact, fib, int, str to see the advantage
# ------------------------------------------------------------

#!/usr/bin/python3
# ----------------------------------------------------------e95-dict.py
# Chapter 5.5 Similarities among Sting, Tuple, List, Range
#             and some more functions
#   Please read that section on your own.
# ------------------------------------------------------------
# Chapter 5.6 Dictionary
# ------------------------------------------------------------
# dictionaries are key-value pairs
# ------------------------------------------------------------
# a dictionary is an object of type dict
# ------------------------------------------------------------
# a literal of type dict is written with braces
# where each element looks like
# key : value
# --------------------------------------------------
monthnumbers = {'Jan' : 1, 'Feb' : 2, 'Mar' : 3, 'Apr' : 4, 'May': 5} 
# --------------------------------------------------
# Show how to iterate through the keys
# --------------------------------------------------
for month in monthnumbers :
    print(month, monthnumbers[month])
print('----------------------------')
# --------------------------------------------------
# Show that a dictionary is mutable by adding aother element
# --------------------------------------------------

# -----------------------------------------------
# Note: that the order in which the keys appear is not defined.
# Note: key search is efficient because of hasing
# -----------------------------------------------



#!/usr/bin/python3
# --------------------------------------------------------------e96-dictCat
# 
# --------------------------------------------------------------
# Read a file catinhat.txt, and count how many different words
# and what is the most frequent word
# ----------------------------------------------------------
pass

# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e100.py
# Chapter 5.6 Dictionary
# ------------------------------------------------------------
# Useful operations on dictionary d
# where k means key, and v means value
# ------------------------------------------------------------
# len(d)
# ------------------------------------------------------------
# d.keys()
# ------------------------------------------------------------
# d.values()
# ------------------------------------------------------------
# k in d
# ------------------------------------------------------------
# d.get(k, v)
# ------------------------------------------------------------
# d[k]
# ------------------------------------------------------------
# d[k] = v
# ------------------------------------------------------------
# del d[k]
# ------------------------------------------------------------
# for k in d :
# ------------------------------------------------------------
birthstones = {'Jan' : 'Garnet', 'Feb' : 'Amethyst', 'Mar' : 'Acquamarine',
               'Apr' : 'Diamond', 'May' : 'Emerald'}
print('birthstones:', birthstones)
a = 'blue'



#!/usr/bin/python3
import unittest
# --------------------------------------------------------------e97-testSpecs
# Chapter 6 on testing, but 
# mixing in some other questions
# --------------------------------------------------------------
# What can testing reveal?  ____________________
# What is black box testing? __________________
# What is glass box testing? __________________
# --------------------------------------------------------------
def mostfrequent(L) :
    '''
    Assume that L is a non-empty list.
    Return the number which is most frequent in the list.
    For example, 
    mostfrequent([5, 2, 9, 2, 9, 1, 18, 9, 3]) would return 9, since 
    there are three 9's, and two 2's, and one of other values.
    '''
    pass
# --------------------------------------------------------------
# The Testing
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
  self.assertEqual(mostfrequent([5, 2, 9, 2, 9, 1, 18, 9, 3]), 9)
 def test2(self):
  self.assertEqual(mostfrequent(['cat', 'dog', 'dog', 'cat', 'cat']), 'cat')
 def test3(self):
  self.assertEqual(mostfrequent([5]), 5)
 def test4(self):
  self.assertEqual(mostfrequent([1, 2, 3, 3, 2, 1]), 2)
 def test5(self):
  self.assertEqual(mostfrequent([(5, 5, 5), (3, 2, 1), (5, 5, 5)]), (5, 5, 5))


if __name__ == '__main__':
 unittest.main(exit=True)




# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import unittest
# -----------------------------------------------------e98-testPartitions
# Chapter 6 on testing, but 
# mixing in some other questions
# --------------------------------------------------------------
# What is a partition: _________________
# Possible partitions for the question below
#       x                  y
#   positive              positive
#   positive              negative
#   negative              positive
#   negative              negative
#       0                   0
#       0                   not 0
#     not 0                 0
# ------------------------------------------------------
# Finding good partitions can be difficult
# look at paths through the specifications and paths through the code
# --------------------------------------------------------------
def isSmaller(x, y) :
    '''
    Assume that x, y are integers
    Return True if x is less than y, False otherwise
    '''
    pass
# --------------------------------------------------------------
# The Testing   Fill in the following by the partitions
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
  self.assertEqual(isSmaller(), True)
 def test2(self):
  self.assertEqual(isSmaller(), False)
 def test3(self):
  self.assertEqual(isSmaller(), True)
 def test4(self):
  self.assertEqual(isSmaller(), False)
 def test5(self):
  self.assertEqual(isSmaller(), True)
 def test6(self):
  self.assertEqual(isSmaller(), True)
 def test7(self):
  self.assertEqual(isSmaller(), True)

if __name__ == '__main__':
 unittest.main(exit=True)


# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import unittest
# --------------------------------------------------------------e99-testBCs
# Chapter 6 on testing, but 
# mixing in some other questions
# --------------------------------------------------------------
# Black box testing explores paths through:
#
# Glass box testing explores paths through:

# ----------------------------------------------------------
# What are boundary conditions?
# boundary conditions for list:
# boundary conditions for numbers: 
# --------------------------------------------------------------
def sqrt(x, epsilon) :
    '''
    Assume: x, epsilon are floating point numbers
    x >= 0
    epsilon > 0
    Returns y such that
    x - epsilon <= y * y <= x + epsilon
    '''
    pass
# --------------------------------------------------------------
# The Testing   Try the boundary conditions for numbers
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
     self.assertEqual(sqrt(0.0, 0.0001), 0.0)
 def test2(self):
     x, epsilon  = 25.0, 0.0001
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)
 def test3(self):
     x, epsilon  = 0.5, 0.0001
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)
 def test4(self):
     x, epsilon  = 2.0, 0.0001
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)
 def test5(self):
     # try 64
     x, epsilon  = 2.0, 1.0 / 2.0 ** 32
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)
 def test6(self):
     # try 64
     x, epsilon  = 2.0 ** 32, 1.0 / 2.0 ** 32
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)
 def test7(self):
     # try 64
     x, epsilon  = 2.0 ** 32, 2.0 ** 32
     y = sqrt(x, epsilon)
     error = abs(y * y - x)
     self.assertTrue(error <= epsilon)

if __name__ == '__main__':
 unittest.main(exit=True)


# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import unittest
# --------------------------------------------------------------e104
# Chapter 6 on testing
# --------------------------------------------------------------
# Black box testing should never be skipped, but you also need ..
# Glass box testing can show where a test might be useful
# ----------------------------------------------------------
def isprime(n) :
    '''
    Assume: n is nonnegative integer
    Return True if n is prime, False otherwise
    '''
    # <= 2
    pass
# --------------------------------------------------------------
# The Testing
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
     self.assertFalse(isprime(10))
 def test2(self):
     self.assertTrue(isprime(3))

if __name__ == '__main__':
 unittest.main(exit=True)


# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import unittest
# --------------------------------------------------------------e104
# Chapter 6 on testing
# --------------------------------------------------------------
# A glass box test suite is path-complete if it tests every path in the code
# Even path-complete test suites may not be sufficient to find all bugs
# ----------------------------------------------------------
def abs(n) :
    '''
    Assume: n is an int
    Returns n if n >= 0 and -n otherwise
    '''
    if n < -1 :
        return -n
    else :
        return n
# --------------------------------------------------------------
# The Testing  {2, -2} is path-complete
# --------------------------------------------------------------
class myTests(unittest.TestCase):
 def test1(self):
     self.assertEqual(abs(2), 2)
 def test2(self):
     self.assertEqual(abs(-2), 2)

if __name__ == '__main__':
 unittest.main(exit=True)


# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
