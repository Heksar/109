                  Friday Oct 9, 2020 Lecture (1h)
		  -------------------------------
Last day (Tuesday) we covered the following:
# ----------------------------------------------------------e59.py
# Chapter 4: Functions: areaOfCircle(r)   
# Loop until sentinel valule
# 4.4 global variables vs local variables
# when is a variable local vs global?
def blue() :
  print(a)
def red() :
  print(a)
  a = 5
def green()
  global a
  print(a)
  a = 5

# ----------------------------------------------------------e60.py
# Chapter 4: Functions: areaOfRectangle(width, height)   
# Two ways of formating the output:
# tab or format string "%5d%5.2f%10s" % (a, b, c)

# ----------------------------------------------------------e61.py
# Chapter 4.2: Functions: printing a pattern of stars

# ----------------------------------------------------------e62.py
# Chapter 4.2: Functions: return statement pattern of stars

# ----------------------------------------------------------e63.py
# Chapter 4.3: Functions stars(n): parameter, argument, recursion

# ----------------------------------------------------------e64.py
# Chapter 4.2: Function stars(n, up): parameters, boolean parameter

# ----------------------------------------------------------e65.py
# Chapter 4.3, 4.4: Functions: fibonacci, iterative and recursive 
# talk about recursion and efficiency and simplicity, global 
# to iterate is human to recurse divine

# ----------------------------------------------------------e66.py
# Chapter 4.2: Functions: mean of a list of numbers

# ========================================================================
#             Today preview
# ========================================================================
# ----------------------------------------------------------e67.py
# Chapter 4.2: Functions: perfect square, exhaustive enumeration
#      boolean return, and return statements in various places
#      practice working with lists

# ----------------------------------------------------------e68.py
# Chapter 4.2: Functions: square root, Heron method
#     redo with function

# ----------------------------------------------------------e69.py
# Chapter 4.2: Functions: exp(x, epsilon)
# Practice with series and epsilon and approximation

# ----------------------------------------------------------e70.py
# Chapter 4.2: Functions: meanSD(xs)     math.sqrt()
# return a list, import math

# ----------------------------------------------------------e71.py
# Chapter 4.2: Functions: recursion   factorial and iteration

# ----------------------------------------------------------e72.py
# Chapter 4.6: Files: opening and reading

# ====================================================================
#!/usr/bin/python3
# ----------------------------------------------------------e67.py
# Chapter 4.2: Functions: perfect square, exhaustive enumeration
#      boolean return, and return statements in various places
#      practice working with lists
# ------------------------------------------------------------
# Write a function perfectsquare(n) that returns True if
# n is a perfect square, and False otherwise.
# Use exhaustive enumeration to answer the question.
# ----------------------------------------------------
# Write a program to try it out.
# -------------------------------------------------------------
def perfectsquare(n) :
    for i in range(0, n + 1) :
        if i ** 2 == n :
            return True
        if i ** 2 > n :
            return False
    return False
# -----------------------------------------------------------------
# Try the function on the following numbers
numbers = [-25, 0, 1, 2, 4, 8, 10, 25, 49, 50, 100]
for number in numbers :
    print(number, 'is a perfect square?', perfectsquare(number))
    
#!/usr/bin/python3
# ----------------------------------------------------------e68.py
# Chapter 4.2: Functions: square root, Heron method
# ------------------------------------------------------------
# Write a function squareroot(x, epsilon) that returns y  
# such that y ** 2 is within epsilon of x.
# Use the Heron or Newton method, where a guess is improved to
# (guess + x/guess) / 2
# ----------------------------------------------------
# Write a program to try it out.
# 0 ..................................................................20
#                               10
#               6
# -------------------------------------------------------------
def squareroot(x, epsilon) :
    '''
    x is assumed to be a positive number, floating point
    return y such that y ** 2 is within epsilon of x
    '''
    guess = x / 2
    while abs(guess ** 2 - x) > epsilon :
        guess = (guess + x/guess) / 2
    return guess

# -----------------------------------------------------------------
# Try the function on the following numbers
numbers = [2, 4, 8, 10, 25, 49, 50, 100, 0, 0.5]
print('x\troot\tsquared')
for number in numbers :
    root = squareroot(number, 0.001)
    sq = root * root
    print(str(number) + '\t' + str(round(root, 2)) + '\t' + str(round(sq, 2)) )
print('--------------')
#!/usr/bin/python3
# ----------------------------------------------------------e69.py
# Chapter 4.2: Functions: exp(x)
# ------------------------------------------------------------
# Write a function exp(x, epsilon) that computes e ^ x
# by the sum of the power series (for n from 0 to infinity) of 
# x ** n / n!
# Do the series until a term is less than epsilon.
# Note that each term is a product of the previous term with (x / n)
# ----------------------------------------------------
# Write a program to try it out.
# -------------------------------------------------------------


# -----------------------------------------------------------------
# Try the function on the following numbers
numbers = [0, 1, 1.5, 2, 5, 0.5]
print('x\te^x')
print('-------------------')


print('--------------')
#!/usr/bin/python3
import math
# ----------------------------------------------------------e70.py
# Chapter 4.2: Functions: meanSD(xs)     math.sqrt()
# returnin a list, import math
# ------------------------------------------------------------
# Write a function meanSD(xs) that computes the mean and the
# standard deviation of a list of n numbers
# The mean is the sum / n
# The standard deviation is sqrt(sum[(x - mean)**2] / (n - 1))
# The function returns [the mean, standard deviation]
# ----------------------------------------------------
# Write a program to try it out.
# -------------------------------------------------------------
def meanSD(xs) :
    n = len(xs)
    mean = sum(xs) / n
    total = 0.0
    for x in xs :
        total = total + (x - mean) ** 2
    sd = math.sqrt(total / (n - 1))
    return [mean, sd]          # return (mean, sd)   returning a tuple
# -----------------------------------------------------------------
# Try the function on the following numbers
numbers = [2, 4, 6, 8]
[mean, sd] = meanSD(numbers)
print('numbers = ', numbers, '[mean, sd] = ', round(mean, 1), round(sd, 2))
print('-------------------')
#!/usr/bin/python3
# ----------------------------------------------------------e71.py
# Chapter 4.2: Functions: recursion   factorial and iteration
# ------------------------------------------------------------
# Write a function facR(n) that computes n! = n(n-1)!
# compare with facI(n), the iterative approach
# ----------------------------------------------------
# Write a program to try it out.
# -------------------------------------------------------------
def facR(n) :
    #base case
    if n < 0 :
        return None
    if n <= 1 :
        return 1
    #general case
    return n * facR(n - 1)
# -----------------------------------------------------------------
# Try the function on the following numbers
numbers = [0, 1, 2, 5, 10]

print('-------------------')
#!/usr/bin/python3
# ----------------------------------------------------------e72.py
# Chapter 4.6: Files: opening and reading
# read a DNA file and calculate the percent of A and T
# ------------------------------------------------------------
f = open('sars-cov2.txt', 'r')  # file handle for reading it
line1 = f.readline()
print(line1)
seq = f.read()
seq = seq.replace('\n', '')
print(seq)
print('number of As', seq.count('A'), 'length is', len(seq))
# ----------------------------------------------------
