#!/usr/bin/python3
from matrices import *
# ---------------------------------------------------------e114_2Dsamerow
# Two-dimensional arrays: 
# --------------------------------------------------------------
# --------------------------------------------------------------
# Determine if any two rows are identical in the matrix
# --------------------------------------------------------------
def equalrows(matrix) :
    '''
    Assume that matrix is a two dimensional array of numbers.
    Returns True if there are two rows that are identical in matrix
      False otherwise
    '''
    pass
# --------------------------------------------------------------
# Try it on matrix1 and matrix2
# --------------------------------------------------------------
for matrix in matrices :
    printmx(matrix)
    print('It is {} that the above matrix has 2 identical rows.'.format(equalrows(matrix)))
pass

# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
from matrices import *
# -------------------------------------------------------e115_2Dsamecol
# Two-dimensional arrays: 
# --------------------------------------------------------------

# --------------------------------------------------------------
# Answer if any two columns are identical in the matrix
# --------------------------------------------------------------
def equalcols(matrix) :
    '''
    Assume that matrix is a rectangular two dimensional array of numbers.
    Returns True if there are two rows that are identical in matrix
      False otherwise
    '''
    pass
# ----------------------------------------------------------
# Try it on matrix1 and matrix2
# --------------------------------------------------------------
for matrix in matrices :
    printmx(matrix)
    print('It is {} that the above matrix has 2 identical rows.'.format(equalcols(matrix)))

# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
from matrices import *
# ---------------------------------------------------------e116_2Dtranspose
# --------------------------------------------------------------
# Make a transpose matrix
# --------------------------------------------------------------
def transpose(matrix) :
    '''
    Assume that matrix is a rectangular two dimensional array of numbers.
    Returns a transpose of the matrix
    '''
    return [[0]]
    pass
# ----------------------------------------------------------
# Try it on matrix1 and matrix2
# --------------------------------------------------------------
for matrix in matrices :
    printmx(matrix)
    print('The transpose of the above matrix is:')
    printmx(transpose(matrix))

# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------e117_exception
# Chapter 7: Exceptions
# --------------------------------------------------------------
# Basic theory:
# Exception is ____
# --------------------------------------------------------------
# Name five common exceptions: ____
# --------------------------------------------------------------
# and show examples of how they can be raised:
# --------------------------------------------------------------
# [1, 2, 3][3] ________
# a = b    before b has been bound to a value  _______
# int(int) __________
# int('abc') ________
# a = 5 / 0 _________
# --------------------------------------------------------------
# Why have exceptions: ____
# --------------------------------------------------------------
# Does a programming language (PL) need exceptions? ____
# --------------------------------------------------------------
# Does a programming language need to offer exception handling: ____
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import random
# ------------------------------------------------------------e118_tryZDE
# Chapter 7: Exceptions
# --------------------------------------------------------------
# Simulate rolling a die 5 times and take guesses for the outcomes
# Print the ratio of successes to failures,
# but watch out for division by 0
# --------------------------------------------------------------
# Pseudocode
# --------------------------------------------------------------
# 0. initialize the guesses, say to 6, 1, 5, 1, 5        #19
# 1. initialize countright and countwrong
# 2. loop 5 times
# 3. roll die
# 4. compare with guess
# 5. change countright or countwrong
# 6. try block to
# 7. evaluate the ratio
# 8. print the ratio
# 9. print done try
# 10. except if there is a zero division error
# 11. print no failures, so no ratio
# 12. print done except
# --------------------------------------------------------------
pass
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# --------------------------------------------------------e118_tryVEwrong
# Chapter 7: Exceptions
# --------------------------------------------------------------
# a) Use exception handling to do an input loop
# where you ask for an integer and then square it.
# --------------------------------------------------------------
# Pseudocode (a variation that does not work properly)
# --------------------------------------------------------------
# 1. While forever
# 2. Get from a user, an input value that should be an integer
# 3. and at the same time convert it to an integer
# 4. Set up a try block
# 5. print the square of the integer
# 6. break out of the forever loop since we just want to do it once
# 7. Set up an except block that handles a ValueError exception
# 8. Print a message that says that was not an integer you gave
pass
# --------------------------------------------------------------
# Try it out
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# ------------------------------------------------------e119_tryVEwrong
# Chapter 7: Exceptions
# --------------------------------------------------------------
# a) Use exception handling to do an input loop
# where you ask for an integer and then square it.
# --------------------------------------------------------------
# Pseudocode (a variation that does not work properly)
# --------------------------------------------------------------
# 1. Set up a try block
# 2. While forever
# 3. Get from a user, an input value that should be an integer
# 4. convert the string input value to an integer
# 5. print the square of the integer
# 6. break out of the forever loop since we just want to square input once
# 7. Set up an except block that handles a ValueError exception
# 8. Print a message that says that was not an integer you gave
pass
# --------------------------------------------------------------
# Try it out
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# -------------------------------------------------------e120_tryVEright
# Chapter 7: Exceptions
# --------------------------------------------------------------
# a) Use exception handling to do an input loop
# where you ask for an integer and then square it.
# --------------------------------------------------------------
# Pseudocode
# --------------------------------------------------------------
# 1. While forever
# 2. Get from a user, an input value that should be an integer
# 3. Set up a try block
# 4. convert the string input value to an integer
# 5. print the square of the integer
# 6. break out of the forever loop since we just want to do it once
# 7. Set up an except block that handles a ValueError exception
# 8. Print a message that says that was not an integer you gave
pass
# --------------------------------------------------------------
# Try it out
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# ---------------------------------------------------------e121_readint
# Chapter 7: Exceptions
# --------------------------------------------------------------
# The code on the previous page is a bit bulky if you have to
# read an integer in several places.
# 
# Convert it to a function that
# a) Use exception handling to do an input loop
# where you ask for an integer repeatedly until you get it, then return it
# --------------------------------------------------------------
def readint() :
    # 1. while forever
    # 2. ask the user for an integer
    # 3. set up a try block
    # 4. convert the input value to an integer
    # 5. return the integer
    # 6. set up an except block for a ValueError exception
    # 7. tell the user that that was not an integer
    pass
# --------------------------------------------------------------
# Try it out:
# --------------------------------------------------------------
a = readint()
print(a, 'squared is', a ** 2)
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
import math
# -------------------------------------------------------e122_readvalue
# Chapter 7: Exceptions
# --------------------------------------------------------------
# The code in e122 can be generalized to any type
# by using a POLYMORPHIC function 
# which is possible in this example because 
# types are FIRST CLASS OBJECTS in Python
# --------------------------------------------------------------
def readvalue(valueType, requestMsg, errorMsg) :
    # 1. while forever
    # 2. ask the user for input using the request message
    # 3. set up a try block
    # 4. convert the input string to type valueType
    # 5. return the converted value (which ends the forever loop)
    # 6. set up an except block for a ValueError exception
    # 7. print the error message (after which control goes back to 1)
    pass
# --------------------------------------------------------------
# Try it out:
# --------------------------------------------------------------
a = readvalue(int, 'Provide an integer', 'is not an integer')
print(a, 'squared is', a ** 2)
a = readvalue(float, 'Provide a floating point number', 'is not a float')
print(a, 'the ceiling is', math.ceil(a))
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# -------------------------------------------------------e123_except_tuple
# Chapter 7: Exceptions: finger exercise from text
# Illustrates a tuple of except errors
# --------------------------------------------------------------
# Write a function to sum the digits in a string, and
# use exception handling to handle a bad argument
# 1. try to do a block
# 2. initialize sum
# 3. loop through the letters
# 4. if the letter is a digit
# 5. add its value to sum
# 6. return the sum
# 7. except block for problems like TypeError or AttributeError
# 8. return None
# --------------------------------------------------------------
def sumdigits(s) :
    '''
    Assumes that s is a string.
    Returns the sum of the digits that are in the string.
    '''
    pass
# --------------------------------------------------------------
# Try it out:
# --------------------------------------------------------------
value = 'a3bc4d'
print(value, 'has digits adding to:', sumdigits(value))
value = 5429
print(value, 'has digits adding to:', sumdigits(value))
value = [int, float, str]
print(value, 'has digits adding to:', sumdigits(value))

# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# -----------------------------------------------------------e124_raiseVE
# Chapter 7: Exceptions: Control the flow
# Exceptions are better than returning special value
# since they don't count on the user to test for it
# Exceptions make errors OVERT which is good
# If exceptions are raised and not handled, _____
# --------------------------------------------------------------
# raise exceptionName(args)
# raise ValueError('some message')
# --------------------------------------------------------------
def findfirsteven(L) :
    '''
    Assumes L is a list of integers
    Returns first even number
    Raises ValueError if L has no even number
    '''
    # Loop through elements of L
    # if an element is even
    # then return the element
    # raise the exception since no even value was found
    pass
# --------------------------------------------------------------
# Try it out:
# --------------------------------------------------------------
L = [3, 2, 9, 8, 5]
print(findfirsteven(L))
L = [7, 1, 5, 21, 33]
print(findfirsteven(L))
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# -------------------------------------------------------e125_controlflow
# Chapter 7: Exceptions: Control the flow
# This example illustrates contolling the flow.
# and float('nan'), float('NaN') as ways to make the
# floating point type nan which means not a number
# since there is no literal for nan
# --------------------------------------------------------------
def getRatios(v1, v2) :
    '''
    Assumes v1, v2 are equal length lists of numbers
    Returns list of meaningful ratios v1[i] / v2[i]
    '''
    # 1. initialize list ratios
    # 2. Loop through indices of v1 
    # 3. try something
    # 4. append to ratios the ratio of i'th elements
    # 5. except for ZeroDivisionError
    # 6. append nan
    # 7. except for any other error
    # 8. raise a ValueError about the bad arguments
    # 9. return the computed list
    pass
# --------------------------------------------------------------
# Try it out:
# --------------------------------------------------------------
L1 = [7,  1,   5,   21,   33]
L2 = [3,  2,   9,     8,    0]
L3 = [2,  9,   8,     0]
try :
    print(getRatios(L1, L2))
    print(getRatios(L1, L3))
    print(getRatios([], []))
except ValueError as msg :
    print(msg)
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# -----------------------------------------------------------e126_assert
# Chapter 7: Exceptions: Control the flow
# Assertions are good debugging tools to confirm
# the state of computation or result so far
# assert Boolean expression
# assert Boolean expression, argument
# if the Boolean expression evaluates to True then
# execution continues as usual
# otherwise an AssertionError is raised
# --------------------------------------------------------------
def rectanglar(matrix) :
    '''
    Assumes matrix is a 2D matrix
    Returns a list which of products of the columns
    '''
    # 1. initialize samelength to True
    # 2. and m to length of first row
    # 3. loop through the rows
    # 4. and change samelength to False if not same length
    # 5. assert that samelength is True
    # 6. 
    # 7. except for any other error
    # 8. raise a ValueError about the bad arguments
    # 9. return the computed list
    pass
# --------------------------------------------------------------
# Try it out:
# --------------------------------------------------------------
L1 = [7,  1,   5,   21,   33]
L2 = [3,  2,   9,     8,    0]
L3 = [2,  9,   8,     0]
try :
    print(getRatios(L1, L2))
    print(getRatios(L1, L3))
    print(getRatios([], []))
except ValueError as msg :
    print(msg)
# --------------------------------------------------------------
# The End
# --------------------------------------------------------------
#!/usr/bin/python3
# ----------------------------------------------------------matrices
# This file will be used for importing the print matrix function
# It is just like e118_print, but it will not print things when imported
# ----------------------------------------------------------
# ----------------------------------------------------------
# Printing a matrix of numbers
# --------------------------------------------------------------
def printmx(mx) :
    for i in range(len(mx)) :
        printrow(mx[i])
    print('-------------------')
def printrow(row) :
    for i in range(len(row)) :
        print('{:4d}'.format(row[i]), end = '')
    print()
# ----------------------------------------------------------
# Defining a couple of matrices to try out the printing
# --------------------------------------------------------------
matrix1 = [[7, 24, 12], [50, 16, 42], [42, 48, 40], [32, 16, 5], [50, 16, 42]]
matrix2 = [[7, 24, 7, 1, 2], [50, 16, 50, 3, 4], [42, 48, 42, 5, 6], [32, 16, 32, 7, 8], [50, 1, 50, 9, 10]]
matrix3 = [[90]]
matrix4 = [[90, 32, 17, 19, 32, 14, 3]]
matrix5 = [[90], [32], [17], [19], [32], [14], [3]]
matrices = [matrix1, matrix2, matrix3, matrix4, matrix5]
# ----------------------------------------------------------
# Printing the matrices, but only if this file is run, not imported
# --------------------------------------------------------------
pass
# ----------------------------------------------------------
# The End
# --------------------------------------------------------------

